<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Test</title>
</head>
<body>
  <div id="info"></div>

    <style>
    html, body {
  height: 100%;
  margin: 0;
  overflow: hidden;
}
canvas {
  width: 100%;
  height: 100%;
  display: block;
}

    </style>
            <script src="https://unpkg.com/three"></script>
        <script src="https://threejs.org/build/three.min.js"></script>
        <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
<script src="https://unpkg.com/@seregpie/three.text-texture"></script>
<script src="https://unpkg.com/@seregpie/three.text-sprite"></script>
    <script>
var scene = new THREE.Scene();

var loader = new THREE.FontLoader();
    loader.load( 'https://raw.githubusercontent.com/rollup/three-jsnext/master/examples/fonts/gentilis_bold.typeface.json', function ( font ) {
      var geometry = new THREE.TextGeometry( 'Fur die Kinder, die', {
        font: font,
        size: 0.14,
        height: 0.01,
        curveSegments: 3,
      } );
      geometry.center();
      var material = new THREE.MeshPhongMaterial({color: 0x000000});
      var mesh = new THREE.Mesh( geometry, material );
      mesh.position.set( 2 , 2.2 ,0);
      mesh.rotation.y -= Math.PI/2;

      var geometry2 = new THREE.TextGeometry( 'morgens zur Schule mussen, die', {
        font: font,
        size: 0.14,
        height: 0.01,
        curveSegments: 3,
      } );
      geometry2.center();
      var material2 = new THREE.MeshPhongMaterial({color: 0x000000});
      var mesh2 = new THREE.Mesh( geometry2, material2 );
      mesh2.position.set( 2 , 1.9 , 0.6);
      mesh2.rotation.y -= Math.PI/2;


    	scene.add( mesh, mesh2 );
    } );

    class Wall {
  constructor( sizeX , sizeY , position ){
    var wall = new THREE.Mesh(
      new THREE.PlaneBufferGeometry( sizeX ,  sizeY ), 
      new THREE.MeshStandardMaterial({ 
        color: 0xf2f2f2,
        shininess: 0
      })
    );
    if( position != undefined ) wall.position.copy( position );
    wall.castShadow = wall.receiveShadow = true;
    return wall;
  }
}

class WhiteWall {
  constructor( sizeX , sizeY , position ){
    var wall = new THREE.Mesh(
      new THREE.PlaneBufferGeometry( sizeX ,  sizeY ), 
      new THREE.MeshStandardMaterial({ 
        color: 0xffffff,
        shininess: 0
      })
    );
    if( position != undefined ) wall.position.copy( position );
    wall.castShadow = wall.receiveShadow = true;
    return wall;
  }
}

class Floor {
  constructor( sizeX , sizeY , position ){
    var wall = new THREE.Mesh(
      new THREE.PlaneBufferGeometry( sizeX ,  sizeY ), 
      new THREE.MeshStandardMaterial({ 
        color: 0xffffff,
        shininess: 1
      })
    );
    if( position != undefined ) wall.position.copy( position );
    wall.castShadow = wall.receiveShadow = true;
    return wall;
  }
}

class PLHelper {
  constructor( diameter , color , position ){
    var helper = new THREE.Mesh(
      new THREE.SphereBufferGeometry( diameter/2 , 5 , 5 ), 
      new THREE.MeshBasicMaterial({ 
        color: color
      })
    );
    if( position != undefined ) helper.position.copy( position );
    return helper;
  }
}

var camera = new THREE.PerspectiveCamera(60, 1, 1, 1000);
camera.position.set(-1, 1.5, 2);
var renderer = new THREE.WebGLRenderer({
  antialias: true
});
renderer.shadowMap.enabled = true;
// renderer.shadowMap.type = THREE.VSMShadowMap;	
renderer.shadowMap.type = THREE.PCFSoftShadowMap;	
// renderer.physicallyCorrectLights = true;

var canvas = renderer.domElement
document.body.appendChild(canvas);
var controls = new THREE.OrbitControls(camera, canvas);
var targetPos = new THREE.Vector3( 1 , 1 , 0 );
camera.lookAt( targetPos );
controls.target.copy( targetPos );

var clock = new THREE.Clock();
var t = 0;

// Lights
var ambientL = new THREE.AmbientLight(0xcccccc, 0.8);
var pointL = new THREE.PointLight( 0x005070 ,  15 , 19 , 2 );
var pointB = new THREE.PointLight( 0x005070 ,1 , 0 ,2);
var pointC = new THREE.PointLight( 0xffffff , 0.8 , 0 , 2);
var pointD = new THREE.PointLight( 0xffffff , 0.2 , 0 , 2);

pointL.castShadow = true;
pointL.shadow.bias = 0.005;

pointB.castShadow = true;
pointB.shadow.bias = 0.005;

pointC.castShadow = true;
pointC.shadow.bias = 0.005;

pointD.castShadow = true;
pointD.shadow.bias = 0.005;


pointL.position.set( 15 , 2 , -6 );
pointB.position.set( 2 ,1.3 , -0.6 );
pointC.position.set(-4 ,0.9 , -6);
pointD.position.set(-1 ,0.9 , 0);

var pHelper = new PLHelper( 0.5 , 0xff55dd );
var pHelper2 = new PLHelper( 0.5 , 0xfffff );
var pHelper3 = new PLHelper( 0.5 , 0xfffff );

// pointL.add( pHelper );
// pointB.add( pHelper2 );
// pointC.add(pHelper3);
//pointD.add(pHelper3)
var compensationDirL = new THREE.DirectionalLight( 0xffffff , 0.1 );
compensationDirL.position.set( -0.3 , 1 , 0 );

scene.add(ambientL, pointL , compensationDirL,pointB,pointC,pointD);


// GROUND
var ground = new Floor( 20 , 20 );
ground.geometry.rotateX(-Math.PI * 0.5);

// WALLS
var wallLeft = new WhiteWall( 20 , 10 );
wallLeft.position.set(0, 5, -7);
var wallRight = new WhiteWall( 10 , 10 );
wallRight.position.set( 2 , 4 , 4 );
wallRight.rotation.y -= Math.PI/2;


scene.add( ground , wallLeft , wallRight );



render();

function render() {
  if (resize(renderer)) {
    camera.aspect = canvas.clientWidth / canvas.clientHeight;
    camera.updateProjectionMatrix();
  }
  
  renderer.render(scene, camera);
  requestAnimationFrame(render);
}

function resize(renderer) {
  const canvas = renderer.domElement;
  const width = canvas.clientWidth;
  const height = canvas.clientHeight;
  const needResize = canvas.width !== width || canvas.height !== height;
  if (needResize) {
    renderer.setSize(width, height, false);
  }
  return needResize;
}
    </script>

</body>
</html>